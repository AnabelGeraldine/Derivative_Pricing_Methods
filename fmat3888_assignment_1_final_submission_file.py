# -*- coding: utf-8 -*-
"""FMAT3888 Assignment 1 FINAL SUBMISSION FILE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XVi9DxLLkG1LnhFE9C1MMs0x_6J_wzWm

# FMAT3888 ASSIGNMENT 1
"""

import random
import time
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib as mplt
import pandas as pd
import numpy as np
import scipy as scp
from scipy import stats
from scipy.stats import norm
from scipy.stats import qmc
from scipy.special import erfinv
from scipy.optimize import minimize
import warnings
import sys

warnings.filterwarnings('ignore')
sns.set(style="darkgrid")

"""## 1. Monte Carlo

## 1.1 Monte Carlo (example for beginners)

In this example, we are trying to estimate the value of pi. Utilising Monte Carlo to this concept allows us to estimate the value of pi. By the help of the library random, we are able to apply Monte Carlo in Python. Code 1.1 estimates the value of pi using Monte Carlo by resampling it on 100, 1000, 10000, and 100000 simulations. The plot provides an illustration that shows how as the number of simulation increases, it approaches the value of pi.

Repeating the simulation 100 times. In other words, resampling it with 100 simulations.
"""

N = 100
M = 0

for _ in range(N):
    x = random.uniform(0, 1)
    y = random.uniform(0, 1)
    if x**2 + y**2 <= 1:
        M += 1

pi_estimate = 4 * M / N
print("The estimated value of pi is " + str(pi_estimate))

"""Repeating the simulation 1000 times. In other words, resampling it with 1000 simulations."""

N = 1000
M = 0

for _ in range(N):
    x = random.uniform(0, 1)
    y = random.uniform(0, 1)
    if x**2 + y**2 <= 1:
        M += 1

pi_estimate = 4 * M / N
print("The estimated value of pi is " + str(pi_estimate))

"""Repeating the simulation 10000 times. In other words, resampling it with 10000 simulations."""

N = 10000
M = 0

for _ in range(N):
    x = random.uniform(0, 1)
    y = random.uniform(0, 1)
    if x**2 + y**2 <= 1:
        M += 1

pi_estimate = 4 * M / N
print("The estimated value of pi is " + str(pi_estimate))

"""Repeating the simulation 100000 times. In other words, resampling it with 100000 simulations."""

N = 100000
M = 0

for _ in range(N):
    x = random.uniform(0, 1)
    y = random.uniform(0, 1)
    if x**2 + y**2 <= 1:
        M += 1

pi_estimate = 4 * M / N
print("The estimated value of pi is " + str(pi_estimate))

"""As we can see, the more simulations we applied, the closer the value goes to the exact value of pi."""

def estimate_pi(N):
    M = 0
    for _ in range(N):
        x = random.uniform(0, 1)
        y = random.uniform(0, 1)
        if x**2 + y**2 <= 1:
            M += 1
    return 4 * M / N

N_values = [100, 1000, 10000, 100000]
pi_estimates = []

for N in N_values:
    pi_estimates.append(estimate_pi(N))

plt.plot(N_values, pi_estimates, marker='o')
plt.axhline(y=3.14159, color='r', linestyle='--', label='Actual π')
plt.xscale('log')
plt.xlabel('Number of Points (N)')
plt.ylabel('Estimated π')
plt.title('Estimation of π using Monte Carlo Method')
plt.legend()
plt.show()

"""## 1.2 Monte Carlo for European Call Option"""

#formula for the Black Scholes Closed Formula
def BS_Call_E(S0, K, T, r, sigma):
    d1 = (np.log(S0/K) + (r + 0.5 * sigma**2)*T) / (sigma*np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return (S0 * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2))

"""### 1.2.1 Standard Monte Carlo for European Call

S&P 500 MINI SPX OPTIONS INDEX (^XSP) is chosen as the underlying asset. The initial stock price (S0) is fixed at 552.89, and the strike price (K) is 330. The time to maturity (T) is set as 1.04 years, derived from the 380 days between September 4, 2024, and September 19, 2025. The risk-free interest rate (r) is estimated to be 4.38%. These parameters are used to simulate terminal stock prices and estimate the cost of a European call option.
"""

# last price is 233.34
S0 = 552.89
K = 330   # strike price
T = 1.04   # time to maturity (from 4 September 2024 to 19 September 2025), hence 380/365
r = 0.0438  # rate is 4.38%
sigma = 0.54  # implied volatility for S&P stock
N = 1000

np.random.seed(0)
Z = np.random.standard_normal(N)
ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)

payoff = np.maximum(ST - K, 0)

C = np.exp(-r * T) * np.mean(payoff)
print(f"European Call Option Price: {C:.2f}")

"""In order to see how different number of simulations affect the result, the following code and graph shows the trend of different number of simulations for the standard Monte Carlo"""

bs_price = BS_Call_E(S0, K, T, r, sigma)


S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54

np.random.seed(0)

simulation_counts = [100, 500, 1000, 5000, 10000, 50000, 100000]
option_prices = []

for N in simulation_counts:
    Z = np.random.standard_normal(N)
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoff = np.maximum(ST - K, 0)
    C = np.exp(-r * T) * np.mean(payoff)
    option_prices.append(C)

plt.figure(figsize=(8, 6))
plt.plot(simulation_counts, option_prices, marker='o', color='royalblue', linestyle='-', linewidth=2, markersize=8)
plt.text(simulation_counts[-1] + 5, option_prices[-1] + 0.5, f'Estimation: {option_prices[-1]:.2f}', fontsize=10, ha='right')
plt.xscale('log')
plt.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.xlabel('Number of Simulations', fontsize=12, fontweight='bold')
plt.ylabel('European Call Option Price', fontsize=12, fontweight='bold')
plt.axhline(y=bs_price, color='r', linestyle='--', label=f'Black Scholes Price: {bs_price:.2f}')
plt.legend()
plt.title('European Call Option Price vs Number of Simulations', fontsize=14, fontweight='bold')
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.tight_layout()
plt.show()

"""As the number of simulations approach 10^5, the prices start to converge to the same final price."""

def monte_carlo_option_price(S0, K, T, r, sigma, N):
    Z = np.random.standard_normal(N)
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoff = np.maximum(ST - K, 0)
    return np.exp(-r * T) * np.mean(payoff)

S0 = 552.89  # last price
K = 330  # strike price
T = 1.04  # time to maturity (from 4 September 2024 to 19 September 2025)
r = 0.0438  # rate is 4.38%
sigma = 0.54  # implied volatility for S&P stock
max_simulations = 100000
step = 1000
num_steps = max_simulations // step
prices = []
errors = []
simulations = []

np.random.seed(0)

for i in range(1, num_steps + 1):
    N = i * step
    price = monte_carlo_option_price(S0, K, T, r, sigma, N)
    prices.append(price)
    simulations.append(N)

    std_error = np.std(prices) / np.sqrt(len(prices))
    errors.append(std_error)

final_price = prices[-1]

plt.figure(figsize=(12, 6))
#changed option price to 'estimated option price'
plt.plot(simulations, prices, label='Estimated Option Price')
plt.fill_between(simulations,
                 [p - 1.96*e for p, e in zip(prices, errors)],
                 [p + 1.96*e for p, e in zip(prices, errors)],
                 alpha=0.2, label='95% Confidence Interval')
#plt.axhline(y=final_price, color='r', linestyle='--', label=f'Final Price: {final_price:.2f}')
plt.axhline(y = bs_price, color = 'r', linestyle = '--', label = f"Black Scholes Price: {bs_price:.2f}")
plt.xlabel('Number of Simulations')
plt.ylabel('Option Price')
plt.title('Convergence of Monte Carlo Estimation for European Call Option Price')
plt.legend()
plt.xscale('log')
plt.grid(True)
plt.show()

relative_errors = [abs(price - final_price) / final_price for price in prices]
convergence_rate = np.polyfit(np.log10(simulations), np.log10(relative_errors), 1)[0]
print(f"Final estimated option price: {final_price:.2f}")

"""The plot shows that as we reach 10^5 simulations, the option price starts to converge to the final price of 254.96.

##### Calculations for the standard Monte Carlo
"""

def black_scholes_call(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def monte_carlo_call(S0, K, T, r, sigma, N):
    Z = np.random.standard_normal(N)
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoff = np.maximum(ST - K, 0)
    return np.exp(-r * T) * np.mean(payoff)

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
N = 1000

np.random.seed(0)
start_time = time.time()
mc_price = monte_carlo_call(S0, K, T, r, sigma, N)
end_time = time.time()

computation_time = end_time - start_time
absolute_error = abs(mc_price - bs_price)
relative_error = absolute_error / bs_price

payoffs = np.maximum(S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * np.random.standard_normal(N)) - K, 0)
standard_error = np.std(payoffs, ddof=1) / np.sqrt(N)

print(f"Monte Carlo Option Price: {mc_price:.2f}")
print(f"Black-Scholes Option Price: {bs_price:.2f}")
print(f"Absolute Error: {absolute_error:.4f}")
print(f"Relative Error: {relative_error:.4f}")
print(f"Computation Time: {computation_time:.4f} seconds")
print(f"Standard Error: {standard_error:.4f}")

efficiency = 1 / (standard_error**2 * computation_time)
print(f"Efficiency: {efficiency:.4e}")

precision = 1 / standard_error
print(f"Precision: {precision:.4f}")

"""##### Terminal distribution of the standard Monte Carlo simulation"""

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
N = 1000

np.random.seed(0)
Z = np.random.standard_normal(N)
ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)

plt.figure(figsize=(10, 6))
plt.hist(ST, bins=50, color='royalblue', edgecolor='black', alpha=0.8)
plt.title('Terminal Distribution of the Monte Carlo Simulation', fontsize=16, fontweight='bold')
plt.xlabel('Stock Price at Maturity', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.6)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

"""### 1.2.2 Monte Carlo Anthitethic for European Call"""

S0 = 552.89
K = 330   # strike price
T = 1.04   # time to maturity (from 4 September 2024 to 19 September 2025), hence 380/365
r = 0.0438  # rate is 4.38%
sigma = 0.54  # implied volatility for S&P stock
N = 1000

np.random.seed(0)

Z = np.random.standard_normal(N)

ST_original = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
ST_antithetic = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * (-Z))

payoff_original = np.maximum(ST_original - K, 0)
payoff_antithetic = np.maximum(ST_antithetic - K, 0)

C_antithetic = np.exp(-r * T) * np.mean((payoff_original + payoff_antithetic) / 2)
C_standard = np.exp(-r * T) * np.mean(payoff_original)

print(f"European Call Option Price (Antithetic): {C_antithetic:.2f}")
print(f"European Call Option Price (Standard): {C_standard:.2f}")

se_antithetic = np.std((payoff_original + payoff_antithetic) / 2) / np.sqrt(N)
se_standard = np.std(payoff_original) / np.sqrt(N)

print(f"Standard Error (Antithetic): {se_antithetic:.4f}")
print(f"Standard Error (Standard): {se_standard:.4f}")

def black_scholes_call(S, K, T, r, sigma):
    d1 = (np.log(S/K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def monte_carlo_pricing(S0, K, T, r, sigma, N, antithetic=False):
    np.random.seed(0)
    Z = np.random.standard_normal(N)

    ST_original = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoff_original = np.maximum(ST_original - K, 0)

    if antithetic:
        ST_antithetic = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * (-Z))
        payoff_antithetic = np.maximum(ST_antithetic - K, 0)
        payoff = (payoff_original + payoff_antithetic) / 2
    else:
        payoff = payoff_original

    option_price = np.exp(-r * T) * np.mean(payoff)
    standard_error = np.std(payoff) / np.sqrt(N)

    return option_price, standard_error

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54

bs_price = black_scholes_call(S0, K, T, r, sigma)
print(f"Black-Scholes Price: {bs_price:.4f}")

num_simulations = [1000 * 2**i for i in range(10)]  # From 1,000 to 512,000
standard_prices = []
standard_errors = []
antithetic_prices = []
antithetic_errors = []

for N in num_simulations:
    standard_price, standard_error = monte_carlo_pricing(S0, K, T, r, sigma, N, antithetic=False)
    antithetic_price, antithetic_error = monte_carlo_pricing(S0, K, T, r, sigma, N, antithetic=True)

    standard_prices.append(standard_price)
    standard_errors.append(standard_error)
    antithetic_prices.append(antithetic_price)
    antithetic_errors.append(antithetic_error)

plt.figure(figsize=(12, 10))
plt.subplot(2, 1, 1)
plt.semilogx(num_simulations, standard_prices, label='Standard MC', marker='o')
plt.semilogx(num_simulations, antithetic_prices, label='Antithetic MC', marker='s')
plt.axhline(y=bs_price, color='r', linestyle='--', label='Black-Scholes Price')
plt.xlabel('Number of Simulations')
plt.ylabel('Option Price')
plt.title('Convergence of Option Price Estimates')
plt.legend()
plt.grid(True)

plt.subplot(2, 1, 2)
plt.loglog(num_simulations, standard_errors, label='Standard MC', marker='o')
plt.loglog(num_simulations, antithetic_errors, label='Antithetic MC', marker='s')
plt.xlabel('Number of Simulations')
plt.ylabel('Standard Error')
plt.title('Reduction in Standard Error')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

print(f"\nFinal Results (with {num_simulations[-1]} simulations):")
print(f"Standard MC Price: {standard_prices[-1]:.4f}, Error: {standard_errors[-1]:.4f}")
print(f"Antithetic MC Price: {antithetic_prices[-1]:.4f}, Error: {antithetic_errors[-1]:.4f}")
print(f"Error Reduction: {(1 - antithetic_errors[-1]/standard_errors[-1])*100:.2f}%")

def black_scholes_call(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
N = 1000

bs_price = black_scholes_call(S0, K, T, r, sigma)

np.random.seed(0)
start_time = time.time()

Z = np.random.standard_normal(N)
ST_original = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
ST_antithetic = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * (-Z))
payoff_original = np.maximum(ST_original - K, 0)
payoff_antithetic = np.maximum(ST_antithetic - K, 0)
C_antithetic = np.exp(-r * T) * np.mean((payoff_original + payoff_antithetic) / 2)

end_time = time.time()
computation_time_antithetic = end_time - start_time

start_time = time.time()
C_standard = np.exp(-r * T) * np.mean(payoff_original)
end_time = time.time()
computation_time_standard = end_time - start_time

absolute_error_antithetic = abs(C_antithetic - bs_price)
relative_error_antithetic = absolute_error_antithetic / bs_price
absolute_error_standard = abs(C_standard - bs_price)
relative_error_standard = absolute_error_standard / bs_price

se_antithetic = np.std((payoff_original + payoff_antithetic) / 2) / np.sqrt(N)
se_standard = np.std(payoff_original) / np.sqrt(N)

efficiency_antithetic = 1 / (se_antithetic**2 * computation_time_antithetic)
precision_antithetic = 1 / se_antithetic
efficiency_standard = 1 / (se_standard**2 * computation_time_standard)
precision_standard = 1 / se_standard

efficiency_improvement = efficiency_antithetic / efficiency_standard
precision_improvement = precision_antithetic / precision_standard

data = {
    "Metric": ["Black-Scholes Price", "Option Price", "Absolute Error", "Relative Error",
               "Computation Time (s)", "Standard Error", "Efficiency", "Precision",
               "Efficiency Improvement", "Precision Improvement"],
    "Antithetic Variates": [f"{bs_price:.2f}", f"{C_antithetic:.4f}", f"{absolute_error_antithetic:.4f}",
                            f"{relative_error_antithetic:.4f}", f"{computation_time_antithetic:.4f}",
                            f"{se_antithetic:.4f}", f"{efficiency_antithetic:.4e}", f"{precision_antithetic:.4f}",
                            f"{efficiency_improvement:.2f}x", f"{precision_improvement:.2f}x"],
    "Standard Monte Carlo": ["", f"{C_standard:.4f}", f"{absolute_error_standard:.4f}",
                             f"{relative_error_standard:.4f}", f"{computation_time_standard:.4f}",
                             f"{se_standard:.4f}", f"{efficiency_standard:.4e}", f"{precision_standard:.4f}", "", ""]
}

df = pd.DataFrame(data)
print(df)

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
N = 1000

np.random.seed(0)
Z = np.random.standard_normal(N)

ST_original = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
ST_antithetic = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * (-Z))

ST_combined = np.concatenate((ST_original, ST_antithetic))

plt.figure(figsize=(10, 6))
plt.hist(ST_combined, bins=50, color='royalblue', edgecolor='black', alpha=0.8)
plt.title('Terminal Distribution of the Monte Carlo Simulation (Antithetic Variates)', fontsize=16, fontweight='bold')
plt.xlabel('Stock Price at Maturity', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.6)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

"""### 1.2.3 Multilevel Monte Carlo (Extension to the materials covered in class)"""

def european_call_payoff(S, K):
    return np.maximum(S - K, 0)

def simulate_stock_price(S0, T, r, sigma, N):
    dt = T / N
    S = np.zeros(N + 1)
    S[0] = S0
    for t in range(1, N + 1):
        Z = np.random.normal()
        S[t] = S[t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    return S

def mlmc_european_call(S0, K, T, r, sigma, L, M):
    P = np.zeros(L)
    for l in range(L):
        N = 2**l
        payoff_sum = 0
        for _ in range(M):
            S = simulate_stock_price(S0, T, r, sigma, N)
            payoff_sum += european_call_payoff(S[-1], K)
        P[l] = np.exp(-r * T) * payoff_sum / M
    return np.mean(P)

S0 = 552.89
K = 330   # strike price
T = 1.04   # time to maturity (from 4 September 2024 to 19 September 2025), hence 380/365
r = 0.0438  # rate is 4.38%
sigma = 0.54  # implied volatility for S&P stock
M = 1000    # number of samples per level
L = 5     # number of levels

option_price_mlmc = mlmc_european_call(S0, K, T, r, sigma, L, M)
print(f"Estimated European call option price (MLMC): {option_price_mlmc:.2f}")

def european_call_payoff(S, K):
    return np.maximum(S - K, 0)

def simulate_stock_price(S0, T, r, sigma, N):
    dt = T / N
    S = np.zeros(N + 1)
    S[0] = S0
    for t in range(1, N + 1):
        Z = np.random.normal()
        S[t] = S[t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    return S

def mlmc_european_call(S0, K, T, r, sigma, L, M):
    P = np.zeros(L)
    for l in range(L):
        N = 2**l
        payoff_sum = 0
        for _ in range(M):
            S = simulate_stock_price(S0, T, r, sigma, N)
            payoff_sum += european_call_payoff(S[-1], K)
        P[l] = np.exp(-r * T) * payoff_sum / M
    return np.mean(P)

def black_scholes_call(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
M = 1000
L = 5

start_time = time.time()
option_price_mlmc = mlmc_european_call(S0, K, T, r, sigma, L, M)
end_time = time.time()
computation_time = end_time - start_time

bs_price = black_scholes_call(S0, K, T, r, sigma)

absolute_error = abs(option_price_mlmc - bs_price)
relative_error = absolute_error / bs_price

payoffs = np.array([mlmc_european_call(S0, K, T, r, sigma, L, M) for _ in range(30)])
standard_error = np.std(payoffs, ddof=1)

efficiency = 1 / (standard_error**2 * computation_time)
precision = 1 / standard_error

print(f"MLMC Option Price: {option_price_mlmc:.2f}")
print(f"Black-Scholes Price: {bs_price:.4f}")
print(f"Absolute Error: {absolute_error:.4f}")
print(f"Relative Error: {relative_error:.4f}")
print(f"Computation Time: {computation_time:.4f} seconds")
print(f"Standard Error: {standard_error:.4f}")
print(f"Efficiency: {efficiency:.4e}")
print(f"Precision: {precision:.4f}")

import numpy as np
import matplotlib.pyplot as plt

def european_call_payoff(S, K):
    return np.maximum(S - K, 0)

def simulate_stock_price(S0, T, r, sigma, N):
    dt = T / N
    S = np.zeros(N + 1)
    S[0] = S0
    for t in range(1, N + 1):
        Z = np.random.normal()
        S[t] = S[t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    return S

def mlmc_european_call(S0, K, T, r, sigma, L, M):
    P = np.zeros(L)
    for l in range(L):
        N = 2**l
        payoff_sum = 0
        for _ in range(M):
            S = simulate_stock_price(S0, T, r, sigma, N)
            payoff_sum += european_call_payoff(S[-1], K)
        P[l] = np.exp(-r * T) * payoff_sum / M
    return np.mean(P)

# Parameters
S0 = 552.89
K = 330   # strike price
T = 1.04   # time to maturity (from 4 September 2024 to 19 September 2025), hence 380/365
r = 0.0438  # rate is 4.38%
sigma = 0.54  # implied volatility for S&P stock

# Convergence study
max_levels = 8
max_samples = 10000
levels_range = range(2, max_levels + 1)
samples_range = [10, 50, 100, 500, 1000, 5000, 10000]

results = np.zeros((len(levels_range), len(samples_range)))

for i, L in enumerate(levels_range):
    for j, M in enumerate(samples_range):
        results[i, j] = mlmc_european_call(S0, K, T, r, sigma, L, M)

# Plotting
plt.figure(figsize=(12, 8))
for i, L in enumerate(levels_range):
    plt.semilogx(samples_range, results[i, :], 'o-', label=f'L={L}')

plt.xlabel('Number of Simulations per Level (M)')
plt.ylabel('Option Price')
plt.title('Convergence of Multilevel Monte Carlo for level 9')
plt.legend()
plt.grid(True)

plt.xticks(samples_range, [f'{x:,}' for x in samples_range])

plt.tight_layout()
plt.show()

final_estimate = mlmc_european_call(S0, K, T, r, sigma, max_levels, max_samples)
print(f"\nFinal Estimated European call option price (MLMC): {final_estimate:.2f}")

"""The plot above shows most of the levels converge to the same value at 10^4 number of simulations"""

def european_call_payoff(S, K):
    return np.maximum(S - K, 0)

def simulate_stock_price(S0, T, r, sigma, N):
    dt = T / N
    S = np.zeros(N + 1)
    S[0] = S0
    for t in range(1, N + 1):
        Z = np.random.normal()
        S[t] = S[t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    return S

def mlmc_european_call(S0, K, T, r, sigma, L, M):
    P = np.zeros(L)
    ST_combined = []
    for l in range(L):
        N = 2**l
        payoff_sum = 0
        for _ in range(M):
            S = simulate_stock_price(S0, T, r, sigma, N)
            payoff_sum += european_call_payoff(S[-1], K)
            ST_combined.append(S[-1])
        P[l] = np.exp(-r * T) * payoff_sum / M
    return np.mean(P), ST_combined

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
M = 1000
L = 5

option_price_mlmc, ST_combined = mlmc_european_call(S0, K, T, r, sigma, L, M)
print(f"Estimated European call option price (MLMC): {option_price_mlmc:.2f}")

plt.figure(figsize=(10, 6))
plt.hist(ST_combined, bins=50, color='royalblue', edgecolor='black', alpha=0.8)
plt.title('Terminal Distribution of the Multilevel Monte Carlo Simulation', fontsize=16, fontweight='bold')
plt.xlabel('Stock Price at Maturity', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.6)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

"""### 1.2.4 Quasi Monte Carlo for European Call"""

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
n_samples = 1000

sobol = qmc.Sobol(d=1, scramble=False)
samples = sobol.random(n_samples)

Z = qmc.scale(samples, l_bounds=[-1], u_bounds=[1])
Z = np.sqrt(2) * erfinv(Z)

ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)

payoffs = np.maximum(ST - K, 0)

price = np.exp(-r * T) * np.mean(payoffs)

print(f"European Call Option Price: {price:.2f}")

plt.figure(figsize=(10, 6))
plt.hist(ST, bins=50, alpha=0.8, color='royalblue', edgecolor='black')
plt.title('Distribution of Terminal Stock Prices', fontsize=16, fontweight='bold')
plt.xlabel('Stock Price', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.6)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

def qmc_option_price(n_samples):
    S0 = 552.89
    K = 330   # Strike price
    T = 1.04   # Time to maturity
    r = 0.0438  # rate is 4.38%
    sigma = 0.54  # Volatility

    sobol = qmc.Sobol(d=1, scramble=False)
    samples = sobol.random(n_samples)
    Z = qmc.scale(samples, l_bounds=[-1], u_bounds=[1])
    Z = np.sqrt(2) * erfinv(Z)
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoffs = np.maximum(ST - K, 0)
    price = np.exp(-r * T) * np.mean(payoffs)
    return price

max_samples = 10000
sample_points = np.logspace(1, 4, 50).astype(int)
prices = [qmc_option_price(n) for n in sample_points]

plt.figure(figsize=(10, 6))
plt.semilogx(sample_points, prices, 'b-')
plt.title('Quasi-Monte Carlo Convergence for European Call Option Pricing')
plt.xlabel('Number of Samples')
plt.ylabel('Option Price')
plt.grid(True)

final_price = qmc_option_price(max_samples)
#plt.axhline(y=final_price, color='r', linestyle='--', label=f'Final Price: {final_price:.2f}')
plt.axhline(y = bs_price, color = 'r', linestyle = '--', label = f"Black Scholes Price: {bs_price:.2f}")
plt.legend()

plt.show()

print(f"Final European Call Option Price: {final_price:.2f}")

def black_scholes_call(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def qmc_european_call(S0, K, T, r, sigma, n_samples, sobol_engine):
    samples = sobol_engine.random(n_samples)
    Z = stats.norm.ppf(samples).flatten()
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoffs = np.maximum(ST - K, 0)
    return np.exp(-r * T) * np.mean(payoffs)

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
n_samples = 1000

sobol_engine = qmc.Sobol(d=1, scramble=False)

start_time = time.time()
price_qmc = qmc_european_call(S0, K, T, r, sigma, n_samples, sobol_engine)
end_time = time.time()
computation_time = end_time - start_time

bs_price = black_scholes_call(S0, K, T, r, sigma)

absolute_error = abs(price_qmc - bs_price)
relative_error = absolute_error / bs_price

# Estimate standard error
n_replications = 30
prices = np.array([qmc_european_call(S0, K, T, r, sigma, n_samples, sobol_engine) for _ in range(n_replications)])
standard_error = np.std(prices, ddof=1)

efficiency = 1 / (standard_error**2 * computation_time)
precision = 1 / standard_error

print(f"QMC Sobol Option Price: {price_qmc:.4f}")
print(f"Black-Scholes Price: {bs_price:.4f}")
print(f"Absolute Error: {absolute_error:.4f}")
print(f"Relative Error: {relative_error:.4f}")
print(f"Computation Time: {computation_time:.4f} seconds")
print(f"Standard Error: {standard_error:.4f}")
print(f"Efficiency: {efficiency:.4e}")
print(f"Precision: {precision:.4f}")

"""##1.2.5 Control Variates for European Call

Estimating $g(x) = f(x) + \beta_{min} (h^* - h(x))$, where:

- $f(x) = e^{-rT} \cdot (S_T - K)^+$
- $h(x) = e^{-rT} \cdot S_T$
- $h^* = S_0$
- $\beta_{min} = \dfrac{Cov[f(x), h(x)]}{Var(h(x))}$

$e^{-rT} \cdot S_T$ is the control variate because in derivative pricing there is a risk-neutral assumption. As a result, it is known that:
$$
\mathbb{E}[e^{-rT} \cdot S_T] = S_0
$$
"""

def control_variate(S0, K, T, r, sigma, N):
    """
    Function to calculate the estimate under the control variate method
    S0 is the initial price
    K is strike price
    T is the time of expiry
    r is the risk free rate
    sigma is the implied volatility
    N is the number of simulations
    """
    #generate N random variables from the standard normal distributio
    Z = np.random.standard_normal(N)
    #calculate the price of ST
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    #get the payoff
    payoff = np.maximum(ST - K, 0)
    #price adjustment to present value
    f_x = np.exp(-r * T) * payoff
    #calculate control variate
    h_x = np.exp(-r * T) * ST
    #control_variate = S0 - h_x
    control_variate = h_x - S0 #this works better
    #get sample covariance between f_x and h_x
    cov_matrix = np.cov(f_x, h_x)
    #calculate beta
    beta = cov_matrix[0, 1]/np.var(h_x)
    #calculate the samples for new function g_x
    g_x = f_x - (beta * control_variate)
    #mean, so estimated price
    C_CV = np.mean(g_x)

    #correlation between f_x and h_x
    correlation = np.corrcoef(f_x, h_x)[0, 1]
    #print(f"Correlation between f(x) and h(x): {correlation}")

    return C_CV

simulation_counts = [100, 500, 1000, 5000, 10000, 50000, 100000]
option_prices = []

for i in simulation_counts:
    estimate = control_variate(S0, K, T, r, sigma, i)
    option_prices.append(estimate)

# Plot the results
#x_values = range(1, len(results) + 1)
plt.scatter(simulation_counts[-1], option_prices[-1], color='orange', marker='*', s=200, label=f'Estimation: {option_prices[-1]:.2f}', zorder=2)
plt.plot(simulation_counts, option_prices, marker='o', color='royalblue', linestyle='-', linewidth=2, markersize=8, zorder=1)
plt.xscale('log')
plt.axhline(y=bs_price, color='r', linestyle='--', label = f'Final Price: {bs_price:.2f}')
plt.title('Estimated Price of European Call Option as Simulations Increase ')
plt.xlabel('Number of Simulations')
plt.ylabel('Cost of European Call Option')
plt.legend()
plt.show()

max_simulations = 100000
step = 1000
num_steps = max_simulations // step
prices = []
errors = []
simulations = []

for i in range(1, num_steps + 1):
    N = i * step
    price = control_variate(S0, K, T, r, sigma, N)
    prices.append(price)
    simulations.append(N)

    std_error = np.std(prices) / np.sqrt(len(prices))
    errors.append(std_error)

final_price = prices[-1]

plt.figure(figsize=(12, 6))
plt.plot(simulations, prices, label='Estimated Option Price')
plt.fill_between(simulations,
                 [p - 1.96*e for p, e in zip(prices, errors)],
                 [p + 1.96*e for p, e in zip(prices, errors)],
                 alpha=0.2, label='95% Confidence Interval')
plt.axhline(y=bs_price, color='r', linestyle='--', label=f'Final Price: {bs_price:.2f}')
plt.xlabel('Number of Simulations')
plt.ylabel('Option Price')
plt.title('Convergence of Control Variate Estimation for European Call Option Price')
plt.legend()
plt.xscale('log')
plt.grid(True)
plt.show()

relative_errors = [abs(price - final_price) / final_price for price in prices]
convergence_rate = np.polyfit(np.log10(simulations), np.log10(relative_errors), 1)[0]
print(f"Final estimated option price: {final_price:.2f}")

# def black_scholes_call(S, K, T, r, sigma):
#     d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
#     d2 = d1 - sigma * np.sqrt(T)
#     return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# bs_price = black_scholes_call(S, K, T, r, sigma)
start_time = time.time()
option_price_cv = control_variate(S0, K, T, r, sigma, N)
end_time = time.time()
computation_time = end_time - start_time

absolute_error = abs(option_price_cv - bs_price)
relative_error = absolute_error / bs_price

payoffs = np.array([control_variate(S0, K, T, r, sigma, N) for _ in range(30)])
standard_error = np.std(payoffs, ddof=1)

efficiency = 1 / (standard_error**2 * computation_time)
precision = 1 / standard_error

print(f"Control Variate Option Price: {option_price_cv:.2f}")
print(f"Black-Scholes Price: {bs_price:.4f}")
print(f"Absolute Error: {absolute_error:.4f}")
print(f"Relative Error: {relative_error:.4f}")
print(f"Computation Time: {computation_time:.4f} seconds")
print(f"Standard Error: {standard_error:.4f}")
print(f"Efficiency: {efficiency:.4e}")
print(f"Precision: {precision:.4f}")

"""##1.2.6 Importance Sampling for European Call
Need to find a different distribution.

$f(X) = e^{-rT}(S_T - K)^+$, given

$$
S_T = S_0 \cdot e^{(r - \frac{1}{2}\sigma^2)T + \sigma \sqrt{T} X}
$$

Expanding gives us

$$f(X) = (S_0e^{-\frac{1}{2} \sigma^2 T + \sigma \sqrt{T} X} - e^{-rT}K)^+$$

Note that $X \sim N(0, 1)$. Therefore, should try to find an alternative normal distribution with the same variance. Let $q(X)$ be the alternative normal distribution such that $X \sim N(\theta, 1)$.

Achieved importance sampling through applying the mode matching method, $\theta = x^*$, where $x^*$ is the maximum of $f(x)p(x)$.
"""

#### NOTE ALWAYS RUN THE g(x) function and find x_star before doing importance_sampling(...) ######
#f(x)p(x)
def g(x):
    return S0 * np.exp(-0.5 * (sigma ** 2) * T + (sigma * np.sqrt(T) * x)) * (sigma * np.sqrt(T) - x) + np.exp(-r * T) * K * x

# finding x_star
result = minimize(lambda x: -g(x), x0 = 0)
x_star = result.x[0]

######################### ^^^^^^^ IMPORTANT ^^^^^^^^^ #######################################

def importance_sampling(x_star, N, S0, sigma, T, r, K):
    """
    Function to calculate the estimate under the control variate method
    x_star is the mean of the alternative distribution
    S0 is the initial price
    K is strike price
    T is the time of expiry
    r is the risk free rate
    sigma is the implied volatility
    N is the number of simulations
    """
    #generate random variables from the alternative distribution
    Z_alt = np.random.normal(x_star, 1, N)
    #price of the stock under the alternative distribution
    ST_alt = S0 * np.exp((-0.5 * sigma**2 * T) + (sigma * np.sqrt(T) * Z_alt))
    #payoff under the alternative distribution
    payoff_alt = np.maximum(ST_alt - np.exp(-r * T) * K, 0)
    #likelihood estimator
    likelihood_est = np.exp(-x_star * Z_alt + (x_star)**2/2)
    alt = payoff_alt * likelihood_est

    return np.mean(alt)

simulation_counts = [100, 500, 1000, 5000, 10000, 50000, 100000]
option_prices = []

for i in simulation_counts:
    estimate = importance_sampling(x_star, N, S0, sigma, T, r, K)
    option_prices.append(estimate)

# Plot the results
x_values = range(1, len(results) + 1)
plt.plot(simulation_counts, option_prices, marker='o', color='royalblue', linestyle='-', linewidth=2, markersize=8, zorder=1)
plt.scatter(simulation_counts[-1], option_prices[-1], color='orange', marker='*', s=200, label=f'Estimation: {option_prices[-1]:.2f}', zorder=2)

plt.xscale('log')
plt.axhline(y=bs_price, color='r', linestyle='--', label = f'Final Price: {bs_price:.2f}')
plt.title('Estimated Price of European Call Option as Simulations Increase ')
plt.xlabel('Number of Simulations')
plt.ylabel('Cost of European Call Option')
plt.legend()
plt.show()

max_simulations = 100000
step = 1000
num_steps = max_simulations // step
prices = []
errors = []
simulations = []

for i in range(1, num_steps + 1):
    N = i * step
    price = importance_sampling(x_star, N, S0, sigma, T, r, K)
    prices.append(price)
    simulations.append(N)

    std_error = np.std(prices) / np.sqrt(len(prices))
    errors.append(std_error)

final_price = prices[-1]

plt.figure(figsize=(12, 6))
plt.plot(simulations, prices, label='Option Price')
plt.fill_between(simulations,
                 [p - 1.96*e for p, e in zip(prices, errors)],
                 [p + 1.96*e for p, e in zip(prices, errors)],
                 alpha=0.2, label='95% Confidence Interval')
plt.axhline(y=bs_price, color='r', linestyle='--', label=f'Final Price: {bs_price:.2f}')
plt.xlabel('Number of Simulations')
plt.ylabel('Option Price')
plt.title('Convergence of Control Variate Estimation for European Call Option Price')
plt.legend()
plt.xscale('log')
plt.grid(True)
plt.show()

relative_errors = [abs(price - final_price) / final_price for price in prices]
convergence_rate = np.polyfit(np.log10(simulations), np.log10(relative_errors), 1)[0]
print(f"Final estimated option price: {final_price:.2f}")

# def black_scholes_call(S, K, T, r, sigma):
#     d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
#     d2 = d1 - sigma * np.sqrt(T)
#     return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# bs_price = black_scholes_call(S, K, T, r, sigma)
start_time = time.time()
option_price_cv = importance_sampling(x_star, N, S0, sigma, T, r, K)
end_time = time.time()
computation_time = end_time - start_time

absolute_error = abs(option_price_cv - bs_price)
relative_error = absolute_error / bs_price

payoffs = np.array([control_variate(S0, K, T, r, sigma, N) for _ in range(30)])
standard_error = np.std(payoffs, ddof=1)

efficiency = 1 / (standard_error**2 * computation_time)
precision = 1 / standard_error

print(f"Importance Sampling Option Price: {option_price_cv:.2f}")
print(f"Black-Scholes Price: {bs_price:.4f}")
print(f"Absolute Error: {absolute_error:.4f}")
print(f"Relative Error: {relative_error:.4f}")
print(f"Computation Time: {computation_time:.4f} seconds")
print(f"Standard Error: {standard_error:.4f}")
print(f"Efficiency: {efficiency:.4e}")
print(f"Precision: {precision:.4f}")

"""## 1.2.7 Overall calculation for the Monte Carlo methods"""

data = {
    "Metric": [
        "Black-Scholes Price", "Option Price", "Absolute Error", "Relative Error",
        "Computation Time (s)", "Standard Error", "Efficiency", "Precision"
    ],
    "Standard Monte Carlo": [
        "255.59", "240.6885", "14.8997", "0.0583", "0.0001", "9.8075", "1.0610e+02", "0.1020"
    ],
    "Antithetic Variates": [
        "", "253.0721", "2.5161", "0.0098", "0.0012", "4.5552", "3.9822e+01", "0.2195"
    ]
}

mlmc_data = [
    "255.7662", "0.1780", "0.0007", "0.0784", "4.1447", "7.4247e-01", "0.2413"
]

qmc_sobol_data = [
    "254.4327", "1.1554", "0.0045", "0.0014", "1.7884", "2.2541e+02", "0.5592"
]

data["MLMC"] = ["255.5882"] + mlmc_data
data["QMC Sobol"] = ["255.5882"] + qmc_sobol_data

df = pd.DataFrame(data)

print(df.to_string(index=False))

S0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
M = 1000
L = 2

def european_call_payoff(S, K):
    return np.maximum(S - K, 0)

def simulate_stock_price(S0, T, r, sigma, N):
    dt = T / N
    S = np.zeros(N + 1)
    S[0] = S0
    for t in range(1, N + 1):
        Z = np.random.normal()
        S[t] = S[t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    return S

def standard_mc(S0, K, T, r, sigma, n_samples):
    Z = np.random.normal(0, 1, n_samples)
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoffs = np.maximum(ST - K, 0)
    price = np.exp(-r * T) * np.mean(payoffs)
    return price

def antithetic_mc(S0, K, T, r, sigma, n_samples):
    Z = np.random.normal(0, 1, n_samples // 2)
    ST1 = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    ST2 = S0 * np.exp((r - 0.5 * sigma**2) * T - sigma * np.sqrt(T) * Z)
    payoffs = np.maximum(np.concatenate([ST1, ST2]) - K, 0)
    price = np.exp(-r * T) * np.mean(payoffs)
    return price

def quasi_mc(S0, K, T, r, sigma, n_samples):
    sobol = stats.qmc.Sobol(d=1, scramble=False)
    samples = sobol.random(n_samples)
    Z = stats.qmc.scale(samples, l_bounds=[-1], u_bounds=[1])
    Z = np.sqrt(2) * erfinv(Z.flatten())
    ST = S0 * np.exp((r - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z)
    payoffs = np.maximum(ST - K, 0)
    price = np.exp(-r * T) * np.mean(payoffs)
    return price

def mlmc_european_call(S0, K, T, r, sigma, L, M):
    N = 2**L
    payoff_sum = 0
    for _ in range(M):
        S = simulate_stock_price(S0, T, r, sigma, N)
        payoff_sum += european_call_payoff(S[-1], K)
    price = np.exp(-r * T) * payoff_sum / M
    return price

def generate_data():
    simulations = [10, 25, 50, 75] + \
                  [100, 250, 500, 750, 1000] + \
                  [2500, 5000, 7500, 10000] + \
                  [25000, 50000, 75000, 100000]

    standard_mc_prices = [standard_mc(S0, K, T, r, sigma, n) for n in simulations]
    antithetic_mc_prices = [antithetic_mc(S0, K, T, r, sigma, n) for n in simulations]
    quasi_mc_prices = [quasi_mc(S0, K, T, r, sigma, n) for n in simulations]
    multilevel_mc_prices = [mlmc_european_call(S0, K, T, r, sigma, L, n) for n in simulations]

    return simulations, standard_mc_prices, antithetic_mc_prices, quasi_mc_prices, multilevel_mc_prices

simulations, standard_mc_prices, antithetic_mc_prices, quasi_mc_prices, multilevel_mc_prices = generate_data()

fig, axs = plt.subplots(2, 2, figsize=(14, 10))
axs[0, 0].semilogx(simulations, standard_mc_prices, 'b-o', markersize=5)
axs[0, 0].set_title('Standard MC')
axs[0, 0].set_xlabel('Number of Simulations')
axs[0, 0].set_ylabel('Option Price')
axs[0, 0].grid(True)

axs[0, 1].semilogx(simulations, antithetic_mc_prices, 'g-o', markersize=5)
axs[0, 1].set_title('Antithetic MC')
axs[0, 1].set_xlabel('Number of Simulations')
axs[0, 1].set_ylabel('Option Price')
axs[0, 1].grid(True)

axs[1, 0].semilogx(simulations, quasi_mc_prices, 'y-o', markersize=5)
axs[1, 0].set_title('Quasi MC')
axs[1, 0].set_xlabel('Number of Simulations')
axs[1, 0].set_ylabel('Option Price')
axs[1, 0].grid(True)

axs[1, 1].semilogx(simulations, multilevel_mc_prices, 'r-o', markersize=5)
axs[1, 1].set_title('Multilevel MC (Level 9)')
axs[1, 1].set_xlabel('Number of Simulations')
axs[1, 1].set_ylabel('Option Price')
axs[1, 1].grid(True)

plt.tight_layout()
plt.show()

"""## 1.3 Random Path"""

S_0 = 552.89
K = 330
T = 1.04
r = 0.0438
sigma = 0.54
N = 1000
dt = 1/365
barrier = 90

plt.figure(figsize=(10, 8))
for i in range(20):

    normal_rv = np.random.normal(0, 1, size=N)
    scaled = np.sqrt(dt) * normal_rv
    W = np.cumsum(scaled)

    # Simulate the asset price path
    time = np.linspace(0, T, N)  # Time vector
    S = S_0 * np.exp((r - 0.5 * sigma**2) * time + sigma * W)

    # Insert S_0 at the beginning
    S = np.insert(S, 0, S_0)
    time = np.insert(time, 0, 0)  # Corresponding time vector

    #barrier_breached = np.any(S < barrier)
    #print(S)

    #if barrier_breached:
    #    # Find the index where the barrier is breached
    #    breach_index = np.where(S < barrier)[0][0]
    #    print(breach_index)
    #    time = time[:breach_index+1]
    #    S = S[:breach_index+1]

    plt.plot(time, S, alpha = 0.6)

plt.xlabel('Time (Years)')
plt.ylabel('Asset Price')
plt.title('Simulated Asset Price Path')
plt.axhline(y=K, color='red', linestyle='-', label='Strike Price', linewidth=2)
plt.axhline(y=barrier, color='black', linestyle='-', label='Barrier', linewidth=2)
plt.legend()
plt.savefig('random_path.png')
plt.show()

#print(normal_rv)
#print(scaled)
#print(W)
#print(S)

"""### 1.3.1 Random path for European call for 1000 simulations

# 2. Finite Difference Method

### **2.1 Finite Difference Method Explanation and Example (for beginners)**
***Definition***

The Finite Difference Method (FDM) is a numerical technique used to solve partial differential equations (PDEs). In this case, this method is commonly employed to price complex financial instruments where analytical solutions might be difficult or impossible to derive.

In this technique, the domain is differentiated in to a grid and simulation is done for temporal and spatial variations. Simulations can be done in forward, backward or central differential form.

***Example Problem using a symmetric difference***

<!--
<font size="6">  <div class="latex">  -->

$$y^"(t) + y(t) = 0$$

$$y(0) = 1 \ \ \ and\ \ \   y'(0) = 0$$

Find $t$ when $y(t)=-1$ (which is when $y(t)$ hits its first local minimum for $t>0$).

Using a symmetric difference for $u^"$ (from tutorials), we get
$$\frac{d^2y(t)}{dt^2} ≈ \frac{y(t+Δt)-2y(t)+y(t-Δt)}{Δt^2}$$

$$ \therefore y(t+Δt)-2y(t)+y(t-Δt) + Δt^2y(t)  = 0$$
$$  y(t+Δt) = 2y(t) - y(t-Δt) - Δt^2y(t)$$
For the code, we can rewrite this as:
$$  y_{n+1} = 2y_{n} - y_{n-1} - Δt^2y_{n}$$

To get $y_2$ we need $y_1$ and $y_0$. We can try to use a forward difference for $y_1$:

$$\frac{dy(t)}{dt} ≈\frac{y(t+Δt)-y(t)}{Δt}$$
$0≈\frac{y(Δt)-y(0)}{Δt}$, so $y(Δt)=1$

This gives us $y_1$, but we can also use a Taylor expansion to get $y_1$:

$$y(Δt)≈y(0)+y'(0)Δt+\frac{1}{2}y''(0)Δt^2$$
$$=y(0)+y'(0)Δt+\frac{1}{2}(-y(0))Δt^2$$sub $y'(0)=0$:
$$y(Δt)≈y(0)-\frac{1}{2}y(0)Δt^2$$
So for the code we can write this as:
$$y_1=y_0-\frac{1}{2}Δt^2y_0$$
"""

# Setting all the variables:
dt = 2**(-10)  # Time step
T_max = 10  # Maximum time to run simulation (so it doesn't go on forever)
N = int(T_max / dt)  # Number of time steps
t = np.linspace(0, T_max, N+1)
y = np.zeros(N+1) #list of zeroes same length as the number of values
y[0] = 1  # Initial condition from question

# Also need to set the first time step y[1] using the derivative condition y'(0) = 0
y[1] = y[0] - 0.5 * dt**2 * y[0]  # Using a Taylor expansion for first step

# Finite difference scheme
for n in range(1, N):
    y[n+1] = 2*y[n] - y[n-1] - dt**2 * y[n]

    # Stop when y gets to -1 (estimate when y[n] hits the local minimum)
    if y[n+1] > y[n]:
        print(f"Estimated value of pi: {t[n]}")
        break

# Plot the solution
plt.plot(t, y, label='Numerical solution of y(t)')
plt.axhline(0, color='red', linestyle='--', label='y = 0')
plt.xlabel('Time t')
plt.ylabel('y(t)')
plt.title('Simple Harmonic Oscillator ODE (Estimating pi)')
plt.legend()
plt.grid(True)
plt.show()

"""This graph appears to be a cosine graph estimating the value of pi. The estimate is very accurate."""

pi_estimates = []

for i in range(4,13):
    # Setting all the variables:
    dt = 2**(-i)  # Time step
    T_max = 10  # Maximum time to run simulation (just to ensure we don't go on forever)
    N = int(T_max / dt)  # Number of time steps
    # Time array
    t = np.linspace(0, T_max, N+1)

    # Initialize solution array y and set initial conditions
    y = np.zeros(N+1)
    y[0] = 1  # Initial condition: y(0) = 1

    # Also need to set the first time step y[1] using the derivative condition y'(0) = 0
    y[1] = y[0] - 0.5 * dt**2 * y[0]  # Using a Taylor expansion for first step

    # Finite difference scheme
    for n in range(1, N):
        y[n+1] = 2*y[n] - y[n-1] - dt**2 * y[n]

        # Stop when y gets to -1 (estimate when y[n] hits the local minimum)
        if y[n+1] > y[n]:
            pi_estimates.append(t[n])
            break

plt.plot(range(4,13), pi_estimates, marker='o')
plt.axhline(y=3.14159265, color='r', linestyle='--', label='Actual π')
plt.xticks(ticks=range(4,13), labels=[f'$2^{{-{x}}}$' for x in range(4,13)])
plt.xlabel('Size of time step')
plt.ylabel('Estimated π')
plt.title('Estimation of π using Finite Differencing Method')
plt.legend()
plt.show()

"""It shows the instability that can occur for certain step sizes and how the method eventually converges to the correct value as the time step becomes sufficiently small.

#2.2 FDM Methods for European Call PDE
## 2.2.1. Explicit Euler Scheme
The Explicit Euler Method is a straightforward approach for numerical integration to solve ordinary differential equations (ODEs) by stepping forward in increments of time using the derivative's current value.

#### General Formula & Mathematical Explanation
Given an ODE in the form:
$$
\frac{dy}{dt} = f(t, y)
$$

where $y$ is the dependent variable, and $f$ is a function of $y$ and $t$ (time).

The Explicit Euler update formula is:
$$
y_{n+1} = y_n + \Delta t \cdot f(t_n, y_n)
$$

where $\Delta t$ is the time step, $y_n$ is the current value, and $y_{n+1}$ is the next value at time $t_{n+1} = t_n + \Delta t$.

#### Stability & Accuracy
- **Stability**: This method is conditionally stable; its stability depends on the size of the time step $ \Delta t $ . The method can be unstable if $ \Delta t $ is too large, particularly for stiff equations.

- **Accuracy**: It has a first-order accuracy in time, which means the local truncation error per step is proportional to $ \Delta t^2 $, but the global error accumulates linearly with $ \Delta t $.

#### Speed of Computation

The Explicit Euler method is computationally fast per time step since it requires only a single evaluation of the function
𝑓
 per step. However, its need for small time steps to maintain stability can make it computationally expensive for long time intervals.

#### 1.4 Numerical Example for Explcit Scheme

**Assumptions:**
- **Stock price (S)** is constant at  $165.

- **Strike price (K)** of the option is $100.
- **Time to maturity (T)** is 1 year.
- **Risk-free rate (r)** is \( 5\% \) per annum.
- **Volatility (σ)** of the stock is  20\%  per annum.
- **Time step (Δt)** for our simulation is 0.01 years (about 3.65 days).


**Goal:**
Simulate the price evolution of a European call option as time progresses towards maturity, using the Explicit Euler method.


#### Numerical Example: European Call Option Pricing

**Differential Equation:**

The Black-Scholes PDE for a European call option, simplified by focusing only on the time derivative and assuming a constant stock price, can be expressed as:
$$
rS \frac{\partial V}{\partial S} - rV = 0
$$

For this example, we simplify further by only considering the time component with some assumptions about stock price and strike price constants, reducing the equation to:
$$
\frac{\partial V}{\partial t} \approx
-\left( \frac{1}{2} \sigma^2 S^2 \left( \frac{\partial \ln(S/K) + (r + \frac{1}{2} \sigma^2) T}{\sigma \sqrt{T}} \right)^2 \right)
+ rS \left( \frac{\ln(S/K) + (r + \frac{1}{2} \sigma^2)T}{\sigma \sqrt{T}} \right) - rV
$$

This equation is derived by approximating the change in the value of the option over time due to changes in the underlying stock's expected return and volatility.

**Discrete Update Formula:**

Using the Explicit Euler method, the update formula is:
$$
V_{n+1} = V_n - \Delta t \cdot \left( \frac{1}{2} \sigma^2 S^2 \left( \frac{\partial \ln(S/K) + (r + \frac{1}{2} \sigma^2) T}{\sigma \sqrt{T}} \right)^2 + rS \left( \frac{\ln(S/K) + (r + \frac{1}{2} \sigma^2)T}{\sigma \sqrt{T}} \right) - rV_n \right)
$$
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 165
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100
N = 1000
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Ensure S_grid avoids zero for stability and division issues
epsilon = 1e-6
S_grid = np.maximum(S_grid, epsilon)

# Explicit Euler method setup
for i in range(1, N):
    V_prev = V.copy()
    for j in range(1, M):
        dV_ds = (V_prev[j+1] - V_prev[j-1]) / (2 * dS)
        d2V_ds2 = (V_prev[j+1] - 2 * V_prev[j] + V_prev[j-1]) / (dS**2)
        V[j] = V_prev[j] + dt * (0.5 * sigma**2 * S_grid[j]**2 * d2V_ds2 + r * S_grid[j] * dV_ds - r * V_prev[j])

    # Boundary conditions
    V[0] = 0  # Value at S = 0
    V[M] = max(S_grid[M] - K, 0)  # Value at S = S_max

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(S_grid, V, label='Explicit Euler Approximation')
plt.plot(S_grid, exact_values, 'r--', label='Black-Scholes Formula')
plt.title('European Call Option Pricing Using Explicit Euler Method')
plt.xlabel('Stock Price')
plt.ylabel('Option Price')
plt.legend()
plt.grid(True)
plt.ylim(-5, max(V.max(), exact_values.max()) * 1.1)  # Adjust y-limits to ensure visibility
plt.show()

"""Both the numerical estimate and the exact solution are very close or identical at low and high stock prices. For stock prices well below the strike price, both methods correctly value the option near zero, reflecting the minimal likelihood of exercise. At high stock prices, both methods capture the intrinsic value (the difference between the stock price and the strike price).

The method shows reasonable accuracy at the boundaries but fails to capture the correct slope or curvature as seen in the Black-Scholes model, likely due to the coarse discretization of the stock price or the time step.The method appears stable at the chosen discretization but may not generalize well if parameters like volatility, interest rate, or time to maturity vary significantly.

Given the characteristics of European call options, which involve significant financial implications and require high accuracy, especially near critical points like the strike price:

- General Suitability: The Explicit Euler method is generally not suitable for pricing European call options in professional settings due to its lower accuracy and conditional stability.

We can also use the Heat Equation method, where we transform $V$ and the other variables to give us a function $u(t,x)$ that solves:
$$u_t-u_{xx}=0, t>0$$
$$u(0,x) = max[e^{\frac{q-1}{2}x}-e^{\frac{q+1}{2}x}, 0]$$

This transformation makes the problem computationally more achievable than solving the Black-Scholes PDE on its own.
"""

# Parameters for the option pricing
sigma = 0.2
r = 0.05
K = 100
T = 1
q = 2 * r / sigma**2

# Discretization parameters
Z = 1000
M = 100
dt = sigma**2 * T / 2 / Z
dx = 6 * sigma * np.sqrt(T) / M
lambda1 = dt / dx**2

# Initialize the KK list with 100 at each grid point
KK = []
KK = [100 for i in range(M)]

# Initialize x as a grid of stock price positions in transformed space
x = []
x = [0 for i in range(M)]

# Set up the grid in transformed space using the volatility and time
for n in range(M):
    x[n] = -3 * sigma * np.sqrt(T) + (n - 1) * dx

# Initialize u, which holds the option values at each time step
u = []
u = [0 for i in range(M)]

# Set initial conditions for u based on the payoff function for a European Call Option in transformed variables
for n in range(M):
    u[n] = np.maximum(np.exp((q + 1) / 2 * x[n]) - np.exp((q - 1) / 2 * x[n]), 0)

# Time-stepping loop using the explicit Euler method
for m in range(1, Z):
    w = [0 for i in range(M)]
    w[1] = 0
    w[M-1] = np.exp((q + 1) * x[M-1] / 2 + (q + 1)**2 * (m - 1) * dt / 4) - np.exp((q - 1) * x[M-1] / 2 + (q - 1)**2 * (m - 1) * dt / 4)

    # Loop through the interior grid points and apply the explicit Euler scheme
    for n in range(1, M-1):
        w[n] = lambda1 * u[n-1] + (1 - 2 * lambda1) * u[n] + lambda1 * u[n+1]  # update values based on neighboring points

    # Update u for the next time step
    u = w

# Initialize arrays for stock prices (S) and option values (V) in the original space
S = [0 for i in range(M)]
V = [0 for i in range(M)]

# Convert transformed variables back to stock prices and option prices
for n in range(M):
    S[n] = K * np.exp(x[n])
    V[n] = u[n] * K * np.exp(-(q - 1) / 2 * x[n] - (q + 1)**2 / 4 * sigma**2 * T / 2)  # option price

# Interpolate option prices for a range of stock prices
priceXX = []
for i in range(20, 180, 5):  # loop through different stock prices
    n0_funct = (np.log(i / 100) + 3 * sigma * np.sqrt(T)) / dx + 1
    A = np.floor(n0_funct)
    nl = int(A)
    # interpolate option price using neighboring points
    priceXX.append(V[nl] * (nl + 1 - n0_funct) + V[nl + 1] * (n0_funct - nl))

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(range(20, 180, 5), priceXX, label='Explicit Euler Approximation')
plt.plot(S_grid, exact_values, 'r--', label='Black-Scholes Formula')
plt.title('European Call Option Pricing Using Explicit Euler Method (with Heat Equation Transformation)')
plt.xlabel('Stock Price')
plt.ylabel('Option Price')
plt.legend()
plt.grid(True)
plt.ylim(-5, 90)
plt.show()

"""####Advantages and Disadvantages

**Advantages**:
- Straightforward to implement and understand
- Requires relatively low computational resources per time step.

**Disadvantages**:
- The method's stability is conditional on the choice of the time step and space step, requiring careful tuning to avoid numerical instabilities.
-  Being first-order accurate in time, the Explicit Euler method may not capture complex dynamics or sharp transitions effectively
- For financial models involving higher volatility or longer time spans, the method's inaccuracies could lead to significant pricing errors.

## 2.2 Implicit Euler Scheme

The Implicit Euler method is a backward time-stepping method, meaning it uses the function values at the next time step to compute derivatives. This approach can provide greater stability, especially for stiff equations, allowing for larger time steps without numerical instability.

It is particularly useful for stiff equations where explicit methods can be unstable unless extremely small time steps are used.

#### General Formula & Mathematical Explanation


Given an ODE:
$$
\frac{dy}{dt} = f(t, y)
$$
The Implicit Euler update formula is:
$$
y_{n+1} = y_n + \Delta t \cdot f(t_{n+1}, y_{n+1})
$$

This requires solving an equation for $y_{n+1}$ because $f$ depends on $y_{n+1}$, typically necessitating iterative methods or solvers, especially when $f$ is nonlinear.


#### Stability & Accuracy

- **Stability**: Implicit Euler is unconditionally stable for linear problems and is particularly effective for stiff ODEs where explicit methods fail unless extremely small timesteps are used.
- **Accuracy**: It is a first-order method, meaning it converges linearly as the time step decreases. The accuracy is generally lower than higher-order methods, but the increased stability often outweighs this drawback in practice.

#### Speed of Computation
The computation is generally slower per time step compared to explicit methods because it requires solving an algebraic equation at each step. The complexity of solving these equations can vary greatly depending on the problem specifics.

#### Numerical Example for Implicit Scheme
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.linalg import solve_banded

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 165
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100
N = 1000
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Avoid division by zero or very small values of S_grid
epsilon = 1e-6
S_grid = np.maximum(S_grid, epsilon)

# Set up coefficients for the implicit scheme
a = -0.5 * dt * (sigma**2 * S_grid**2 / dS**2 + r * S_grid / dS)
b = 1 + dt * (sigma**2 * S_grid**2 / dS**2 + r)
c = -0.5 * dt * (sigma**2 * S_grid**2 / dS**2 - r * S_grid / dS)

# Ensure a, b, c are finite before solving
if np.any(np.isinf(a)) or np.any(np.isinf(b)) or np.any(np.isinf(c)):
    raise ValueError("Infinite values detected in coefficients")

# Setup tridiagonal matrix
diagonal = np.zeros((3, M + 1))
diagonal[0, 1:] = c[1:]  # Upper diagonal
diagonal[1, :] = b        # Main diagonal
diagonal[2, :-1] = a[:-1] # Lower diagonal

# Time-stepping using the Implicit Euler method
for _ in range(N):
    V[1:M] = solve_banded((1, 1), diagonal, V)[1:M]

# Correct for the far boundary condition
V[-1] = np.maximum(S_grid[-1] - K, 0)

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(S_grid, V, label='Implicit Euler Approximation')
plt.plot(S_grid, exact_values, 'r--', label='Black-Scholes Formula')
plt.title('European Call Option Pricing Using Implicit Euler Method')
plt.xlabel('Stock Price')
plt.ylabel('Option Price')
plt.legend()
plt.grid(True)
plt.ylim(0, max(V.max(), exact_values.max()) * 1.1)  # Adjust y-limits to ensure visibility
plt.show()

"""It shows a significant improvement in the approximation as the stock price increases. his indicates that the method is capturing the intrinsic value behavior of the option correctly in higher stock price ranges. The approximation is almost flat at lower stock prices, staying very close to zero, which is expected behavior for out-of-the-money options where exercising the option is not profitable. While the method captures the overall trend, it may not smooth out the transition as naturally as the Black-Scholes formula.

Implicit Euler is suitable for European call option pricing, particularly for long-term options or situations where the model might be stiff.

It is stable and can handle larger time steps, but has lower accuracy than some other methods (like Crank-Nicolson), and comes with a higher computational cost due to the need to solve linear systems at each time step.

#### Advantages and Disadvantages

Advantages:
- is unconditionally stable, meaning that it remains stable regardless of the size of the time step. Good for stiff problems.
- it allows for larger time steps to be taken without compromising accuracy and leading to fewer steps required to reach a solution (significantly reducing computational cost in time-dependent problems).
- works better when handling boundary conditions, especially when simulating problems like diffusion and heat transfer.

Disadvantages:
- first-order accurate in time, meaning the error decreases linearly with the time step size
- computationally expensive, especially for large-scale problems.
- requires matrix inversion or iterative solvers, which adds complexity to the implementation.

##2.3 Crank Nicolson

The Crank-Nicolson method is a finite difference method used to numerically solve partial differential equations (PDEs), particularly parabolic PDEs, like the Black-Scholes equation used in option pricing. It is a second-order accurate method in both space and time, and it combines both implicit and explicit schemes to achieve a balance between stability and accuracy. The method is widely used because it provides better accuracy than the Implicit Euler method while still maintaining numerical stability, especially for stiff equations.

#### General Formula & Mathematical Explanation


***Crank Nicolson Method: General Formula & Mathematical Explanation***

It solves parabolic PDEs like the **Black-Scholes equation** by averaging the **Explicit Euler** and **Implicit Euler** schemes.

For a PDE of the form:
$$
\frac{\partial V}{\partial t} = \mathcal{L}(V)
$$
where L(𝑉)
 represents spatial derivatives, the Crank-Nicolson discretization is:
$$
\frac{V_i^{n+1} - V_i^n}{\Delta t} = \frac{1}{2} \left( \mathcal{L}(V_i^{n+1}) + \mathcal{L}(V_i^n) \right)
$$
Here, Vi^n represents the value of the option at spatial point  i  and time step n, and L(𝑉)  includes first and second derivatives with respect to stock price S.

Finite Difference Discretization:

For the Black-Scholes PDE:
$$
\frac{\partial V}{\partial t} = \frac{1}{2} \sigma^2 S_i^2 \frac{\partial^2 V}{\partial S^2} + r S_i \frac{\partial V}{\partial S} - r V
$$
The Crank-Nicolson scheme for each time step can be written as:
$$
\frac{V_i^{n+1} - V_i^n}{\Delta t} = \frac{1}{2} \left( \frac{1}{2} \sigma^2 S_i^2 \frac{V_{i-1}^{n+1} - 2V_i^{n+1} + V_{i+1}^{n+1}}{\Delta S^2} + r S_i \frac{V_{i+1}^{n+1} - V_{i-1}^{n+1}}{2 \Delta S} - r V_i^{n+1} \right)
$$
$$
+ \frac{1}{2} \left( \frac{1}{2} \sigma^2 S_i^2 \frac{V_{i-1}^n - 2V_i^n + V_{i+1}^n}{\Delta S^2} + r S_i \frac{V_{i+1}^n - V_{i-1}^n}{2 \Delta S} - r V_i^n \right)
$$
This results in a tridiagonal system of equations that can be solved efficiently.


#### Stability & Accuracy
- **Stability**: unconditionally stable for many linear PDEs, including the Black-Scholes equation. This means that the method remains stable regardless of the time step size
Δ
𝑡
. This is a significant improvement over explicit methods, which can become unstable if
Δ𝑡
 is too large.

- **Accuracy**: second-order accurate in both time and space, meaning that the error per time step decreases quadratically as the time step size
Δ
𝑡
 is reduced. This gives the method a substantial accuracy advantage over first-order methods like the Implicit Euler scheme.

####Speed of Computation
The Crank-Nicolson method allows for larger time steps, meaning fewer time steps are needed to compute the solution. Thus, in practice, the Crank-Nicolson method can often outperform explicit methods in terms of overall computational speed, especially for long-time simulations.

#### Numerical Example of Crank Nicolson
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.linalg import solve_banded

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 200  # Increased max stock price for calculations (but solutions will only be up until S=150)
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100  # Grid points in space
N = 1000  # Grid points in time
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Matrix coefficients
a = 0.25 * dt * (sigma**2 * S_grid**2 / dS**2 - r * S_grid / dS)
b = -dt * 0.5 * (sigma**2 * S_grid**2 / dS**2 + r) - 1
c = 0.25 * dt * (sigma**2 * S_grid**2 / dS**2 + r * S_grid / dS)

# Adjustments for banded matrix solver
lower_band = np.zeros(M+1)
upper_band = np.zeros(M+1)
diagonal = np.zeros(M+1)

lower_band[1:] = a[1:]  # a_i
diagonal[0:-1] = b[0:-1]  # b_i
upper_band[:-1] = c[:-1]  # c_i

# Time stepping loop
for n in range(1, N + 1):
    # Solve Av_n = v_(n-1)
    V = solve_banded((1, 1), (lower_band, diagonal, upper_band), V)

    # Boundary conditions
    V[0] = 0  # Value at S = 0
    V[M] = S_grid[M] - K  # Improved boundary condition for large S

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

print(len(S_grid[S_grid <= 150]))  # Finding the number of points where S <= 150
# since it's 76, we can select only the stock prices up to 150, since the estimate gets unstable for too high of a stock price

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(S_grid[:76], V[:76], label='Crank-Nicolson Approximation')
plt.plot(S_grid[:76], exact_values[:76], 'r--', label='Black-Scholes Formula')
plt.title('European Call Option Pricing Using Crank-Nicolson Method')
plt.xlabel('Stock Price')
plt.ylabel('Option Price')
plt.legend()
plt.grid(True)
plt.ylim(-5, max(V[:76].max(), exact_values[:76].max()) * 1.1)  # Adjust y-limits to ensure visibility
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.linalg import solve_banded

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 200
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100
N = 1000
dt = T / N
dS = S_max / M
S_grid = np.linspace(1e-6, S_max, M + 1)  # Avoid zero for stability
X_grid = np.log(S_grid)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Crank-Nicolson coefficients
alpha = 0.25 * sigma**2 * dt / (dS**2)
beta = r * dt / (2 * dS)

# Create tridiagonal matrix components for A and B
main_diag_A = (1 + 2 * alpha + r * dt) * np.ones(M + 1)
lower_diag_A = (-alpha + beta) * np.ones(M)
upper_diag_A = (-alpha - beta) * np.ones(M)

main_diag_B = (1 - 2 * alpha - r * dt) * np.ones(M + 1)
lower_diag_B = (alpha - beta) * np.ones(M)
upper_diag_B = (alpha + beta) * np.ones(M)

# Building the matrices A and B
# For A
ab_A = np.zeros((3, M + 1))
ab_A[0, 1:] = upper_diag_A
ab_A[1, :] = main_diag_A
ab_A[2, :-1] = lower_diag_A

# For B
ab_B = np.zeros((3, M + 1))
ab_B[0, 1:] = upper_diag_B
ab_B[1, :] = main_diag_B
ab_B[2, :-1] = lower_diag_B

# Solution using the Crank-Nicolson method
for i in range(1, N + 1):
    # Set boundary conditions
    V[0] = 0  # Value at S = 0
    V[M] = max(S_max - K, 0)  # Value at S = S_max

    # Calculate the right-hand side of the equation
    rhs = np.zeros(M+1)
    rhs[1:-1] = ab_B[1,1:-1] * V[1:-1] + ab_B[0,1:-1] * V[2:] + ab_B[2,1:-1] * V[:-2] # Use slicing and explicit calculation for RHS

    # Solve the system
    V = solve_banded((1, 1), ab_A, rhs)


# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

print(len(S_grid[S_grid <= 150]))  # Finding the number of points where S <= 150
# since it's 75, we can select only the stock prices up to 150, since the estimate gets unstable for too high of a stock price

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(S_grid[:75], V[:75], label='Crank-Nicolson Approximation')
plt.plot(S_grid[:75], exact_values[:75], 'r--', label='Black-Scholes Formula')
plt.title('European Call Option Pricing Using Crank-Nicolson Method')
plt.xlabel('Stock Price')
plt.ylabel('Option Price')
plt.legend()
plt.grid(True)
plt.ylim(-5, max(V[:75].max(), exact_values[:75].max()) * 1.1)  # Adjust y-limits to ensure visibility
plt.show()

"""Crank-Nicolson is highly suitable for pricing European call options due to its stability and accuracy. It is ideal for long-maturity options where larger time steps are necessary to make the computation efficient while maintaining high accuracy. However, for short-term options or simple cases, explicit methods may be more efficient.

#### Advantages & Disadvantages
Advantages:
-  remains stable regardless of the size of the time step
Δ
𝑡
. (suitable for stiff problems)
- second-order accurate in both time and space
- a combination of Explicit Euler and Implicit Euler, providing the advantages of both. It’s more accurate than explicit schemes and more stable than purely implicit methods.
-  allows for larger time steps, reducing the total number of time steps required for simulations
- works particularly well for smooth solutions since it doesn't introduce artificial numerical damping (unlike some other schemes). This is useful when pricing European options, where the solution is generally smooth, especially in the absence of early exercise features.

Disadvantages:
- can introduce spurious oscillations, especially for stiff problems or discontinuous initial conditions.
- For higher-dimensional problems (e.g., multi-asset options), solving the system of equations becomes increasingly complex and computationally costly.

##2.4 Metrics Comparison

###a. Explicit
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from time import time

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 150
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100
N = 1000
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Ensure S_grid avoids zero for stability and division issues
epsilon = 1e-6
S_grid = np.maximum(S_grid, epsilon)

# Start computation timer
start_time = time()

# Explicit Euler method setup
for i in range(1, N):
    V_prev = V.copy()
    for j in range(1, M):
        dV_ds = (V_prev[j+1] - V_prev[j-1]) / (2 * dS)
        d2V_ds2 = (V_prev[j+1] - 2 * V_prev[j] + V_prev[j-1]) / (dS**2)
        V[j] = V_prev[j] + dt * (0.5 * sigma**2 * S_grid[j]**2 * d2V_ds2 + r * S_grid[j] * dV_ds - r * V_prev[j])

    # Boundary conditions
    V[0] = 0  # Value at S = 0
    V[M] = max(S_grid[M] - K, 0)  # Value at S = S_max

# Computation time
comp_time = time() - start_time

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

# Calculate errors
absolute_errors = np.abs(V - exact_values)
relative_errors = absolute_errors / (exact_values + epsilon)

# Compute metrics
standard_error = np.std(absolute_errors) / np.sqrt(M)
efficiency = 1 / (comp_time * np.var(absolute_errors))
precision = np.mean(relative_errors)

# Average values for the first four metrics
average_black_scholes_price = np.mean(exact_values)
average_option_price = np.mean(V)
average_absolute_error = np.mean(absolute_errors)
average_relative_error = np.mean(relative_errors)

# Output metrics
metrics = {
    'Average Black-Scholes Price': average_black_scholes_price,
    'Average Option Price': average_option_price,
    'Average Absolute Error': average_absolute_error,
    'Average Relative Error': average_relative_error,
    'Computation Time (s)': comp_time,
    'Standard Error': standard_error,
    'Efficiency': efficiency,
    'Precision': precision
}

metrics

"""- The average values indicate that the Explicit Euler method provides a reasonable approximation to the Black-Scholes prices, though consistently slightly underestimating the true values as reflected in the average option price and average absolute error.
- The relative error being around 3.37% is modest for a simple explicit method, suggesting that while the method is fairly accurate, care must be taken in scenarios requiring high precision.
- The computation time is relatively low, making the - Explicit Euler method a viable option for scenarios where computational speed is critical, albeit at a cost of some accuracy.
The standard error and efficiency provide further insight into the statistical reliability of the results and the trade-offs between speed and accuracy.


##b. Implicit
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.linalg import solve_banded
from time import time

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 150
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100
N = 1000
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Ensure S_grid avoids zero for stability and division issues
epsilon = 1e-6
S_grid = np.maximum(S_grid, epsilon)

# Set up coefficients for the implicit scheme
a = -0.5 * dt * (sigma**2 * S_grid**2 / dS**2 + r * S_grid / dS)
b = 1 + dt * (sigma**2 * S_grid**2 / dS**2 + r)
c = -0.5 * dt * (sigma**2 * S_grid**2 / dS**2 - r * S_grid / dS)

# Setup tridiagonal matrix
diagonal = np.zeros((3, M + 1))
diagonal[0, 1:] = c[1:]  # Upper diagonal
diagonal[1, :] = b        # Main diagonal
diagonal[2, :-1] = a[:-1] # Lower diagonal

# Start computation timer
start_time = time()

# Time-stepping using the Implicit Euler method
for _ in range(N):
    V = solve_banded((1, 1), diagonal, V)

# Computation time
comp_time = time() - start_time

# Correct for the far boundary condition
V[-1] = np.maximum(S_grid[-1] - K, 0)

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

# Calculate errors
absolute_errors = np.abs(V - exact_values)
relative_errors = absolute_errors / (exact_values + epsilon)

# Compute metrics
standard_error = np.std(absolute_errors) / np.sqrt(M)
efficiency = 1 / (comp_time * np.var(absolute_errors))
precision = np.mean(relative_errors)

# Average values for the first four metrics
average_black_scholes_price = np.mean(exact_values)
average_option_price = np.mean(V)
average_absolute_error = np.mean(absolute_errors)
average_relative_error = np.mean(relative_errors)

# Output metrics
metrics = {
    'Average Black-Scholes Price': average_black_scholes_price,
    'Average Option Price': average_option_price,
    'Average Absolute Error': average_absolute_error,
    'Average Relative Error': average_relative_error,
    'Computation Time (s)': comp_time,
    'Standard Error': standard_error,
    'Efficiency': efficiency,
    'Precision': precision
}

metrics

"""- The results indicate significant discrepancies between the Implicit Euler and Black-Scholes prices, with a high average relative error. This could be due to numerical instability or improper boundary condition handling in the Implicit Euler method as implemented.
- The average option price significantly underestimates the correct values as suggested by the Black-Scholes model, and the absolute error is quite high.
- The computation time is very fast, but this advantage is overshadowed by the large errors and low efficiency, making the method potentially unsuitable for precise financial calculations without further adjustments or more refined numerical approaches.
- The standard error is quite high, further indicating significant spread in the errors across the stock price grid, which could be a concern for applications requiring high precision in option pricing.



IMPLICIT, while stable, may not be the best choice for European call options due to its lower accuracy and tendency to damp the solution. This can result in underpricing, particularly near the strike price, which is critical for options. For a more accurate solution, especially when dealing with financial derivatives like options, the Crank-Nicolson method is usually preferred because it provides a better balance between accuracy and stability.

##c. Crank-Nicolson
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.linalg import solve_banded
import time

def black_scholes_call(S, K, T, r, sigma):
    """Calculate the Black-Scholes option price for a European call option."""
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Parameters
S_max = 250  # Increased max stock price for calculations
K = 100
T = 1.0
r = 0.05
sigma = 0.2
M = 100  # Grid points in space
N = 1000  # Grid points in time
dt = T / N
dS = S_max / M
S_grid = np.linspace(0, S_max, M + 1)

# Initial condition
V = np.maximum(S_grid - K, 0)

# Matrix coefficients
a = 0.25 * dt * (sigma**2 * S_grid**2 / dS**2 - r * S_grid / dS)
b = -dt * 0.5 * (sigma**2 * S_grid**2 / dS**2 + r) - 1
c = 0.25 * dt * (sigma**2 * S_grid**2 / dS**2 + r * S_grid / dS)

# Adjustments for banded matrix solver
lower_band = np.zeros(M+1)
upper_band = np.zeros(M+1)
diagonal = np.zeros(M+1)

lower_band[1:] = a[1:]  # a_i
diagonal[0:-1] = b[0:-1]  # b_i
upper_band[:-1] = c[:-1]  # c_i

start_time = time.time()

# Time stepping loop
for n in range(1, N + 1):
    # Solve Av_n = v_(n-1)
    V = solve_banded((1, 1), (lower_band, diagonal, upper_band), V)

    # Boundary conditions
    V[0] = 0  # Value at S = 0
    V[M] = S_grid[M] - K  # Improved boundary condition for large S

computation_time = time.time() - start_time

# Calculate the exact solution for comparison
exact_values = np.array([black_scholes_call(s, K, T, r, sigma) for s in S_grid])

# Metrics
index_S150 = np.where(S_grid <= 150)[0][-1]  # index where S_grid <= 150
option_price = V[index_S150]
bs_price = exact_values[index_S150]
absolute_error = abs(option_price - bs_price)
relative_error = absolute_error / bs_price
std_error = np.std(V[:index_S150] - exact_values[:index_S150])
efficiency = 1 / (computation_time * std_error)
precision = np.mean(abs(V[:index_S150] - exact_values[:index_S150]))

{
    "Black-Scholes Price": bs_price,
    "Option Price": option_price,
    "Absolute Error": absolute_error,
    "Relative Error": relative_error,
    "Computation Time (s)": computation_time,
    "Standard Error": std_error,
    "Efficiency": efficiency,
    "Precision": precision
}

"""The Crank-Nicolson method applied to European call option pricing shows reasonable accuracy and impressive computational efficiency when compared to the Black-Scholes model, with an option pricing discrepancy and a relative error indicating potential for refinement. The computation is quick, which is advantageous in volatile trading environments, but the observed standard error and precision suggest there is consistent variance from the theoretical model. While the method balances speed and precision effectively, as indicated by its efficiency metric, improvements could be made by refining the numerical grid, adjusting model parameters, and improving boundary conditions to enhance accuracy. These steps are crucial for aligning the model more closely with high-precision requirements typical in quantitative finance, especially for risk management and trading strategies.

### Compilation

"""

import pandas as pd

# Data for Explicit Euler method
explicit_euler_data = {
    'Average Black-Scholes Price': 11.424598288879253,
    'Average Option Price': 10.893481732248327,
    'Average Absolute Error': 0.5311909431863806,
    'Average Relative Error': 0.0337125822763787,
    'Computation Time (s)': 0.6006500720977783,
    'Standard Error': 0.11203263978190803,
    'Efficiency': 1.3264452475036141,
    'Precision': 0.0337125822763787
}

# Data for Implicit Euler method
implicit_euler_data = {
    'Average Black-Scholes Price': 11.424598288879253,
    'Average Option Price': 3.708600649988354,
    'Average Absolute Error': 7.715997640350953,
    'Average Relative Error': 0.31592072342660077,
    'Computation Time (s)': 0.05730795860290527,
    'Standard Error': 1.35846163517958,
    'Efficiency': 0.09455626427551751,
    'Precision': 0.31592072342660077
}

# Data for Crank-Nicolson method
crank_nicolson_data = {
    'Average Black-Scholes Price': 54.970140137999195,
    'Average Option Price': 50.658350161975825,
    'Average Absolute Error': 4.31178997602337,
    'Average Relative Error': 0.07843876630474078,
    'Computation Time (s)': 0.03575873374938965,
    'Standard Error': 1.9882907708584734,
    'Efficiency': 14.064942847106103,
    'Precision': 1.884095813561961
}



# Create the DataFrame
df = pd.DataFrame({
    'Explicit Euler': explicit_euler_data,
    'Implicit Euler': implicit_euler_data,
    'Crank-Nicolson': crank_nicolson_data
})

df

"""The provided data compares the performance of three numerical methods—Explicit Euler, Implicit Euler, and Crank-Nicolson—in computing the price of European call options against the Black-Scholes model. The Crank-Nicolson method shows significantly better alignment with the theoretical Black-Scholes prices, as evidenced by its Average Black-Scholes Price and Average Option Price metrics, and a relatively lower Average Relative Error of about 7.84%. Despite having a higher Average Absolute Error compared to the Explicit Euler, this method offers a more accurate approximation in a relative sense, which is crucial for applications where percentage errors are more meaningful than absolute discrepancies.

In terms of computational efficiency and stability, the Crank-Nicolson method outshines the others, showcasing the highest efficiency and the least computational time among the three. Its high efficiency score of 14.06 and the shortest computation time (0.036 seconds) highlight its suitability for real-time financial computations where both accuracy and speed are essential. The method’s higher Standard Error, however, suggests variability in its error distribution, which might require finer parameter tuning or additional stability features in scenarios with highly volatile inputs. In contrast, the Explicit Euler method, while fastest, falls short in precision and efficiency, and the Implicit method, despite its moderate speed, shows the least precision and highest relative errors, indicating potential numerical damping or stability issues that compromise its accuracy.
"""